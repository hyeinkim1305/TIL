# 0303_큐, BFS

### 큐

> 스택과 마찬가지로 삽입과 삭제의 위치가 제한적
>
> 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어짐 (선입선출)
>
> 가장 먼저 삽입된 원소부터 가장 먼저 삭제된다.
>
> 삽입 : enQueue  삭제 : deQueue  ( 삽입할 때는 rear가 움직이고 삭제할 때는 front가 움직임, 교재 참고 )
>
> front와 rear가 같은 값을 가리키고 있으면 공백 상태

- ##### 선형큐

  ✅ 코드 참고

  > 0303 > 암호생성기, Queue 연습문제

  - ##### 1차원 배열을 이용한 큐

    큐의 크기 : 배열의 크기

    front : 마지막에 꺼내진 원소의 인덱스 (저장된 첫번째 원소의 인덱스)

    rear : 저장된 마지막 원소의 인덱스

  - ##### 상태 표현

    초기상태 : front = rear = -1

    공백상태 : front = rear

    포화상태 : rear = n - 1 (n : 배열크기, n-1 : 배열 마지막 인덱스)

  - ##### 잘못된 포화상태 인식
  
    선형큐를 이용하여 삽입과 삭제를 계속하게 되면 배열의 앞부분에 활용할 수 있는 공간이 있음에도 불구하고, rear = n-1인 상태, 즉 포화상태로 인식하여 더 이상 삽입을 수행하지 않게 됨
  
    > 해결방법1
    >
    > 매 연산이 이루어질 때마다 저장된 원소들을 배열의 앞부분으로 모두 이동. 그러나 원소 이동에 많은 시간이 소요되어 효율성이 떨어짐
  >
    > 해결방법 2
  >
    > 1차원 배열을 사용하되, 논리적으로는 배열의 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정 (원형큐의 논리적 구조)

  - ##### 원형큐의 구조

    초기공백상태 : front = rear = 0

    인덱스의 순환 : front와 rear의 위치가 배열의 마지막 인덱스인 n-1를 가리킨 후, 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야함. 이를 위해 나머지 연산자 mod를 사용함 
  
    front 변수 : 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠
  
  |        | 삽입 위치               | 삭제 위치                 |
  | ------ | ----------------------- | ------------------------- |
  | 선형큐 | real = real + 1         | front = front + 1         |
  | 원형큐 | real = (real + 1) mod n | front = (front + 1) mod n |
  
    n : 큐 size, mod : %
  
    > <초기 공백 큐 생성>
    >
    > 1. 크기 n 인 1차원 배열 생성, front와 rear를 0으로 초기화
    >
    > <공백 및 포화상태 검사>
    >
    > 1. 공백상태 : front = rear
    >
    > 2. 포화상태 : 삽입할 rear의 다음 위치 = 현재 front  
    >
    > ​                   (rear+1) mod n = front
    >
    > <삽입>
    >
    > 1. rear값을 조정하여 새로운 원소를 삽입할 자리를 마련 
    >
    >    rear <- (rear+1) mod n
    >
    > 2. 그 인덱스에 해당하는 배열 원소 cQ[rear]에 item 저장
    >
    > <삭제>
    >
    > 1. 가장 앞에 있는 원소를 삭제하기 위해 front 값을 조정하여 삭제할 자리를 준비함
    >
    >    front = (front+1) % len(cQ)
    >
    > 2. 새로운 front 원소를 리턴함으로써 삭제와 동일한 기능을 함

### 우선순위 큐

> 우선순위를 가진 항목들을 저장하는 큐 / 우선순위가 높은 순서대로 먼저 나가게 된다.
>
> 배열 or 리스트 사용 (그러나 배열은 소요되는 시간이나 메모리낭비가 크다)

- 버퍼

  데이터를 일시적으로 보관하는 메모리 영역

### BFS

> 그래프를 탐색하는 방법에는 크게 두가지 (깊이 우선 탐색 / 너비 우선 탐색)
>
> 너비 우선 탐색은 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식
>
> 인접한 정점들에 대해 탐색한 후 너비 우선 탐색을 진행해야 하므로 선입선출 형태의 자료구조인 큐를 활용함 
>
> '최단', '최소' 가 들어갈땐 dfs 보다 bfs가 좋을 수 있음

> ✅ 코드참고
>
> 0303 > BFS 연습문제

처음에 시작정점을 큐에 넣음과 동시에 visited에 표시하고, 시작정점에 인접한 정점들을 큐에 넣느다 반복 