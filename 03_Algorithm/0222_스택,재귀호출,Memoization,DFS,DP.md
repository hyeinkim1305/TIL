# 0222_스택, 재귀호출,Memoization,DFS

### 스택

> 마지막에 삽입한 자료를 가장 먼저 꺼낸다. ''후입선출'' (LIFO) last in first out
>
> 스택에서 마지막 삽입된 원소의 위치 : top
>
> 연산
>
> >  삽입 : 저장소에 자료를 저장한다. push
> >
> > 삭제 : 저장소에서 자료를 꺼낸다. 꺼낸 자료는 삽입한 자료의 역순으로 꺼낸다. pop
> >
> > 스택이 공백인지 아닌지 확인하는 연산 : isEmpty
> >
> > 스택의 top에 있는 item(원소)를 반환하는 연산, peek
>
> 1차원 배열을 사용하여 구현할 경우 스택의 크기를 변경하기 어렵다는 단점이 있다.
>
> > ✅ 코드 참고
> >
> > 0222 > 스택
> >
> > 0223 > 괄호검사, 반복문자지우기

- ##### 스택의 push 알고리즘

  append 메소드를 통해 리스트의 마지막에 데이터를 삽입

- ##### 스택의 pop 알고리즘

  길이가 0이 아니라면 s.pop(-1)

### 재귀호출

> 자기 자신을 호출하여 순환 수행되는 것
>
> if (종료조건) 이 필요하다. base line 필요!
>
> > ✅ 코드 참고
> >
> > 0223 > 종이붙이기

- ##### 팩토리얼

  ```python
  def factorial(n):
      if n == 1:
          return 1
      return n * factorial(n-1)
  ```

- ##### 피보나치수열

  0과 1로 시작하고 이전의 두 수 합을 다음 항으로 하는 수열

  피보나치 수열의 i번째 항을 반환하는 함수를 재귀로 구현

  ```python
  def fibo(n):
      if n < 2:
          return n    # 자기자신 그대로니까!
      else:
          return fibo(n-1) + fibo(n-2)
  ```

  위처럼 하게 되면 구했던 수열들도 다시 구해야해서 불필요한 계산이 많아져서 fibo(40) 부터는 속도가 매우 느려짐. 따라서 한번 구한거는 기록해두는 방식이 좋다.

### Memoization

> 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다.
>
> 동적계획법(DP)의 핵심이 되는 기술이다.

```python
def fibo1(n):
    if n >= 2 and len(memo) <= n:
        memo.append(fibo(n-1)+bibo(n-2))
    return memo[n]
memo = [0, 1]
print(fibo1(40))
```

```python
memo2 = [-1]*21
memo2[0] = 0
memo2[1] = 1
def fibo2(n):
    if memo2[n] == -1:
        memo2[n] = fibo2(n-1) + fibo2(n-2)
    return memo2[n]
print(fibo2(10))
```



### DP(Dynamic Programming)

> 동적계획 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다. 
>
> 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결해 최종적을 구하는 것

- 피보나치 수 DP 적용 알고리즘

  ```python
  def fibo2(n):
      f = [0, 1]
      for i in range(2, n+1):
          f.append(f[i-1]+f[i-2])
      return f[n]
  ```



### DFS(깊이 우선 탐색)

> 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요함
>
> 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색하다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법
>
> 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야하므로 후입선출 구조의 스택 사용
>
> 인접한 것을 아는 방식 2가지 : 인접행렬 / 인접리스트(1. dict, 2. 배열)
>
> > ✅ 코드 참고
> >
> > 0222 > 그래프경로 (인접리스트(dict방법, 배열방법))

- ##### dfs

  푸는 방식 2가지

  - stack : 반복하는 식으로
  - 재귀 : 코드 간결

  1. 시작 정점 v를 결정하여 방문한다.

  2. 정점 v에 인접한 정점 중에서 

     1) 방문하지 않은 정점 W가 있으면, 정점 v를 스택에 push하고 정점 w를 방문한다. 그리고 w를 v로 하여 다시 2.를 반복한다.

     2) 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 2.를 반복한다.

  3. 스택이 공백이 될 때까지 2.를 반복한다.

  > ✅ 코드 참고
  >
  > 0222 > dfs
  >
  > 0223 > 길찾기, 그래프경로(스택,재귀)

- ##### 이차원행렬 dfs

  > ✅ 코드 참고
  >
  > 0302 > 2차원행렬_dfs 
  >
  > : 4방향 탐색하면서 지나온 길은 다른 숫자로 변경하는 방식

  