# 0224_스택2, 백트래킹, 분할정복

### 계산기

>  문자열로 된 계산식이 주어질 때, 스택을 이용하여 이 계산식의 값을 계산할 수 있다.
>
> 1) 중위 표기법의 수식을 후위 표기법으로 변경한다. (스택이용)
>
> 2) 후의 표기법의 수식을 스택을 이용하여 계산한다.



### 백트래킹

> 해를 찾는 도중에 막히면 되돌아가서 다시 해를 찾아가는 기법이다.
>
> 최적화 문제와 결정 문제를 해결할 수 있다.
>
> - 결정 문제 : 문제의 조건을 만족하는 해가 존재하는지의 여부를 'YES' 또는 'NO'가 답하는 문제 

- ##### 백트래킹과 깊이우선탐색과의 차이

  1) 어떤 노드에서 출발하는 경로가 해결책이 되지 않을 것 같으면 더이상 그 경로를 따라가지 않음. 시도의 횟수를 줄임

  2) 깊이 우선 탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단

  3) 백트래킹은 모든 후보를 검사하지 않는다.

- ##### 백트래킹 기법

  어떤 노드의 유망성을 점검한 후에 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가 다음 자식 노드로 감

  어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않다고 하며, 반대로 해답의 가능성이 있으면 유망하다고 한다.

  가지치기 (pruning) : 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않는다.

- ##### 절차

  1. 상태 공간 트리의 깊이 우선 검색을 실시
  2. 각 노드가 유망한지를 점검
  3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속한다.

- ##### 부분집합 구하기

  > 어떤 집합의 공집합과 자기자신을 포함한 모든 부분집합을 powerset이라고 하며 구하고자 하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 개수는 2의 n제곱이 나온다.

  **powerset 재귀**

  ```python
  N = 3
  arr = [1, 2, 3]  # 우리가 활용할 데이터
  sel = [0] * N   # a리스트(내가 해당 원소를 뽑았는지 체크)
  def powerset(idx):
      if idx == N:
          print(*sel)
          return
      sel[idx] = 0   # idx 자리의 원소를 뽑고 간다.
      powerset(idx+1)
      sel[idx] = 1   # idx 자리를 안뽑고 간다.
      powerset(idx+1)
  powerset(0)
  # output
  # 0 0 0
  # 0 0 1
  # 0 1 0
  # 0 1 1
  # 1 0 0 
  # 1 0 1
  # 1 1 0
  # 1 1 1
  ```

  ** 부분집합 생성 방법 3가지 (bitmask, 재귀(위 코드), 재귀로 백트래킹)

  **순열 재귀**

  ```python
  arr = [1, 2, 3]
  N = 3
  sel = [0] * N  # 결과들이 저장될 리스트
  check = [0] * N  # 해당 원소를 이미 사용했는지 안했는지에 대한 체크
  def perm(idx):
      # 다 뽑아서 정리했다면,
      if idx == N:
          print(sel)
      else:
          for i in range(N):
              if check[i] == 0:
                  sel[idx] = arr[i]  # 값을 써라-
                  check[i] = 1  # 사용을 했다는 표시
                  perm(idx+1)
                  check[i] = 0  # 다음 반복문을 위한 원상복구
  perm(0)
  
  # output
  [1, 2, 3]
  [1, 3, 2]
  [2, 1, 3]
  [2, 3, 1]
  [3, 1, 2]
  [3, 2, 1]
                  
  ```

  ##### 순열 비트

  ```python
  arr = [1,2,3]
  N = 3
  sel = [0] * N  # 뽑은 결과를 적음
  def perm(idx, check):
      if idx == N:
          print(sel)
          return
     	for j in range(N):
          # j번째 원소를 활용을 했군. 그럼 쓰면 안되지.
          if check & (1<<j): continue
          sel[idx] = arr[j]
          perm(idx+1, check | (1<<j))  # 원상복구과정이 필요없다.
  perm(0, 0)
  ```

  ##### 순열 스왑

  ```python
  arr = [1,2,3]
  N = 3
  def perm(idx):
      if idx == N:
          print(arr)
      else:
          for i in range(idx, N):
              # 순서를 바꾸고
              arr[idx], arr[i] = arr[i], arr[idx]
              perm(idx+1)
              # 원상복귀
              arr[idx], arr[i] = arr[i], arr[idx]
  perm(0)
  ```



### 분할 정복 알고리즘

- ##### 거듭제곱

  ```python
  # 반복문을 이용한 선형시간 O(n)
  def Iterative_Power(x, n):
      result = 1
      for i in range(1, n+1):
          result *= x
      return result
  
  # 분할정복을 이용한 거듭제곱 O(logN)
  def Recursive_Power(x, n):
      if n == 1: return x
      if n % 2 == 0:
          y = Recursive_Power(x, n//2)
          return y * y
      else:
          y = Recursive_Power(x, (n-1)//2)
          return y*y*x
      
  ```

- ##### 퀵정렬

  > 주어진 배열을 두개로 분할하고, 각각을 정렬한다. 
  >
  > 대강 왼쪽 집합에서 큰거 찾고 오른쪽 집합에서 작은거 찾아서 서로 교환하는 느낌 ~ 만약 그게 같으면 제자리 확정?~
  >
  > 최악의 시간 복잡도는 O(n^2)이지만 빠른 정렬인 이유는 평균 복잡도가 (nlogn)이다.

  

