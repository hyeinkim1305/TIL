# 2차원배열, 부분집합, 비트연산자

- ### 2차원 배열

  ```python
  # 3 4
  # 1 2 3 4
  # 5 6 7 8 
  # 9 1 2 3
  
  # 입력 방법 1
  N, M = map(int, input().split())
  arr = []
  for i in range(N):
      arr.append(list(map(int, input().split())))
      
  # 입력 방법 2
  N, M = map(int, input().split())
  arr = [0] * N
  for i in range(N):
      arr[i] = map(int, input().split())
      
  # 입력 방법 3
  arr = [list(map(int, input().split())) for _ in range(N)]
  ```

  ##### 배열 순회

  ##### 행 우선 순회

  ```python
  for i in range(len(Array)):  # 행 고정, 한 행안에서 열을 순회
  	for j in range(len(Array[i]))
  		Array[i][j]  # 필요한 연산 수행
          
  N = 3 # 행의 길이
  M = 4 # 열의 길이
  for i in range(N):
      for j in range(M):
          print(arr[i][j])
          
  # 행 우선 순회를 역으로 돌아보기
  for i in range(N):
      for j in range(M-1, -1, -1):
          print(arr[i][j])
  ```

  **열 우선 순회**

  ```python
  # i : 행의 좌표
  # j : 열의 좌표
  for j in range(len(Array[0])):
  	for i in range(len(Array)):
  		Array[i][j]
  
  N = 3 # 행의 길이
  M = 4 # 열의 길이
  for j in range(M):
      for i in range(N):
          print(arr[i][j])
  
  # 열 우선 순회를 역으로 돌아보기
  for j in range(M):
      for i in range(N-1, -1, -1):
          print(arr[i][j])
  
      
  ```

  **지그재그 순회**

  ```python
  for i in range(N):
  	if i % 2 == 0:
  		for j in range(M):
  			print(arr[i][j])
  	else:
  		for j in range(M-1, -1, -1):
  			print(arr[i][j])
              
  for i in range(len(Array)):
      for j in range(len(Array[0])):
          Array[i][j + (m-1-2*j) * (i % 2)]
  ```

  **델타를 이용한 2차 배열 탐색**

  2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법

  ```python
  arr = [[1,2,3],
        [4,5,6],
        [7,8,9]]
  
  r = 1
  c = 1
  # 상하좌우
  dr = [-1, 1, 0, 0]
  dc = [0, 0, -1, 1]
  # 상하좌우 이렇게도 가능
  # drc = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  
  for i in range(4):
      nr = r + dr[i]
      nc = c + dc[i]
      print(arr[nr][nc])
  # output
  # 2
  # 8
  # 4
  # 6
  ######################################################
  r = 0
  c = 1
  # 상하좌우
  dr = [-1, 1, 0, 0]
  dc = [0, 0, -1, 1]
  # 상하좌우 이렇게도 가능
  # drc = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  
  for i in range(4):
      nr = r + dr[i]
      nc = c + dc[i]
      print(arr[nr][nc])
  # output  # 에러가 나지 않는다. 왜냐면 -1이 인덱스가 가능하니까
  # 8
  # 5
  # 1
  # 3
  #########################################################
  r = 1
  c = 1
  N = 3
  # 상하좌우
  dr = [-1, 1, 0, 0]
  dc = [0, 0, -1, 1]
  # 상하좌우 이렇게도 가능
  # drc = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  
  for i in range(4):
      nr = r + dr[i]
      nc = c + dc[i]
      # 이것을 추가하면 범위를 초과했을 때를 제한할 수 있음
      if nr < 0 or nr >= N or nc < 0 or nc >= N: continue
      	print(arr[nr][nc])
      
      # if 0<= nr < N and 0<=nc<N:
          # print(arr[nr][nc])
  # output
  # 5
  # 1
  # 3
  ```

  **대각선 네 방향으로 탐색**

  ```
  위와 동일한 방법으로 진행
  ```

  **전치 행렬**

  ```python
  arr = [[1,2,3],[4,5,6],[7,8,9]]
  
  for i in range(3):
  	for j in range(3):
  		if i < j:
  			arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
  ```

- ### 부분집합 합

  완전검색 기법으로 풀려면 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산해야 한다.

  ##### 부분집합의 수

  > 집합의 원소가 n개 일 때, 공집합을 포함한 부분집합의 수는 2 ** n 개이다. 
  >
  > 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같다.

  ```python
  bit = [0, 0, 0, 0]
  
  for i in range(2):
      bit[0] = i
      for j in range(2):
          bit[1] = j
          for k in range(2):
              bit[2] = k
              for l in range(2):
                  bit[3] = l
                  print(bit)
  # output
  [0, 0, 0, 0]  # 0
  [0, 0, 0, 1]  # 1
  [0, 0, 1, 0]  # 2
  [0, 0, 1, 1]  # 3
  [0, 1, 0, 0]
  [0, 1, 0, 1]
  [0, 1, 1, 0]
  [0, 1, 1, 1]
  [1, 0, 0, 0]
  [1, 0, 0, 1]
  [1, 0, 1, 0]
  [1, 0, 1, 1]
  [1, 1, 0, 0]
  [1, 1, 0, 1]
  [1, 1, 1, 0]  # 14
  [1, 1, 1, 1]  # 15
  ```

  ##### 헷갈리면 참고해보기 아래 코드
  
  ```python
  arr = [3,4,6]
  n = len(arr)
  for i in range(1<<n):
      ans = []
      for j in range(n):
          if i & (1<<j):
              print('i', '=', i)
              print('j','=',j)
            ans.append(arr[j])
      print(ans)
  ```
  
  > output
  >
  > ```python
  > []
  > i = 1
  > j = 0
  > [3]
  > i = 2
  > j = 1
  > [4]
  > i = 3
  > j = 0
  > i = 3
  > j = 1
  > [3, 4]
  > i = 4
  > j = 2
  > [6]
  > i = 5
  > j = 0
  > i = 5
  > j = 2
  > [3, 6]
  > i = 6
  > j = 1
  > i = 6
  > j = 2
  > [4, 6]
  > i = 7
  > j = 0
  > i = 7
  > j = 1
  > i = 7
  > j = 2
  > [3, 4, 6]
  > ```
  
  ```python
  arr = [3,6,7,1,5,4]
  n = len(arr)  # n : 원소의 개수
  for i in range(1<<n):   # 1<<n : 부분집합의 개수
      for j in range(n):  # 원소의 수만큼 비트를 비교함
          if i & (1<<j):  # i의 j번째 비트가 1이면 j번째 원소 출력
              print(arr[j], end=", ")
      print()
  print()
  
  ```
  
  > output
  >
  > ```
  > 
  > 3, 
  > 6, 
  > 3, 6, 
  > 7, 
  > 3, 7, 
  > 6, 7, 
  > 3, 6, 7, 
  > 1, 
  > 3, 1, 
  > 6, 1, 
  > 3, 6, 1, 
  > 7, 1, 
  > 3, 7, 1, 
  > 6, 7, 1, 
  > 3, 6, 7, 1, 
  > 5, 
  > 3, 5, 
  > 6, 5, 
  > 3, 6, 5, 
  > 7, 5, 
  > 3, 7, 5, 
  > 6, 7, 5, 
  > 3, 6, 7, 5, 
  > 1, 5, 
  > 3, 1, 5, 
  > 6, 1, 5, 
  > 3, 6, 1, 5, 
  > 7, 1, 5, 
  > 3, 7, 1, 5, 
  > 6, 7, 1, 5, 
  > 3, 6, 7, 1, 5, 
  > 4, 
  > 3, 4, 
  > 6, 4, 
  > 3, 6, 4, 
  > 7, 4, 
  > 3, 7, 4, 
  > 6, 7, 4, 
  > 3, 6, 7, 4, 
  > 1, 4, 
  > 3, 1, 4, 
  > 6, 1, 4, 
  > 3, 6, 1, 4, 
  > 7, 1, 4, 
  > 3, 7, 1, 4, 
  > 6, 7, 1, 4, 
  > 3, 6, 7, 1, 4, 
  > 5, 4, 
  > 3, 5, 4, 
  > 6, 5, 4, 
  > 3, 6, 5, 4, 
  > 7, 5, 4, 
  > 3, 7, 5, 4, 
  > 6, 7, 5, 4, 
  > 3, 6, 7, 5, 4, 
  > 1, 5, 4, 
  > 3, 1, 5, 4, 
  > 6, 1, 5, 4, 
  > 3, 6, 1, 5, 4, 
  > 7, 1, 5, 4, 
  > 3, 7, 1, 5, 4, 
  > 6, 7, 1, 5, 4, 
  > 3, 6, 7, 1, 5, 4, 
  > ```
  
```python
  gradient = ["egg", "cheese", "ricecake"]
  
  N = 3
  for i in range(1<<N):
      ans = ""
      for j in range(N):
          if i & (1<<j):
              ans += gradient[j] + " "
              
      print(ans, "라면입니다.")
```

> output
  >
  > ```
  >  라면입니다.
  > egg  라면입니다.
  > cheese  라면입니다.
  > egg cheese  라면입니다.
  > ricecake  라면입니다.
  > egg ricecake  라면입니다.
  > cheese ricecake  라면입니다.
  > egg cheese ricecake  라면입니다.
  > ```

**비트연산자**

- & : 비트 단위로 AND 연산을 한다.
  
  ```
    0110 & 1011 하게 되면 0010
  ```
  
  ```
    print(6 & 11)
    # output
    2
  ```
  
- | : 비트 단위로 OR 연산을 한다.
  
  ```
    0110 & 1011 하게 되면 1111
  ```
  
  ```
    print(6 | 11)
    # output
    15
  ```
  
- << : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
  
  ```python
    한번 할 때마다 값이 2배씩 증가함
    A << B  :  A에 있는 값을 B번 shift 하겠다는 의미
  ```
  
  ```python
    for i in range(1<<n):     # 위 비트 코드를 이런식으로 대체 가능함
    	pass
  ```
  
- '>>' : 피연산자의 비트 열을 오른쪽으로 이동시킨다.